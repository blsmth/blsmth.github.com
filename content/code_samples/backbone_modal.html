---
extends: base.j2
default_block: main
title: Code Samples - Backbone.js / jQModal
description: Code Sample
---

<h1>Backbone.js Modal Windows</h2>

<p>This code samples is a little different as it is all Javascript.  It's one very small piece of a project I've been working on recently at NPP.  This project is my first time using <a href="http://backbonejs.org/" target="_blank">Backbone.js</a> (and Underscore.js) and it's been awesome.</p>
<p>This code sample is a Backbone View that allows me to create alert and confirmation windows on the fly from anywhere in my code, powered by <a href="http://dev.iceburg.net/jquery/jqModal/" target="_blank">jQModal</a> which is a great little jQuery plugin that provides a lightweight yet very powerful modal window.</p>

<h2>Backbone.js Code</h2>
<p>This code defines the Backbone.js View that we will use to create modals.   I first define a base ModalView class which provides all the underlying power and ties directly to jQModal.  Then I inherit the base class via ModalAlert and ModalConfirm for alerts and confirmations.  ModalAlert takes two arguments: content and title.  ModalConfirm takes 4 arguments: content, title, yes and no, which I will describe later.</p>

{% syntax 'javascript', 'Backbone.js View' %}
// Backbone Views
window.ModalView = Backbone.View.extend({
  tagName: "div",
  className: "modal",

  events: {
    "click .btnClose": "hideModal"
  },

  initialize : function(){
    // bind all functions so we have a sane 'this'
    _.bindAll(this);

    // set title and content
    this.title = this.options.title;
    this.content = this.options.content;

    // attach the rendered div element to the body element
    $('body').append(this.render().el);


    // setup and show jqModal
    this.$el.jqm({overlay: 30, modal: true, trigger: false });
    this.$el.jqmShow();
  },

  destroy: function() {

    // completely unbind this view and delete all traces of it
    this.undelegateEvents();
    $(this.el).removeData().unbind();
    this.remove();
    Backbone.View.prototype.remove.call(this);
    delete this;

  },

  render: function() {
    this.$el.html(this.template(this));
    return this;
  },

  showModal: function() {
    this.$el.jqmShow();
    return this;
  },

  hideModal: function() {
    this.$el.jqmHide();
    this.destroy();
    return this;
  },


});


window.ModalAlert = ModalView.extend({
    className: "modal alert",
    template: _.template($('#modal-template').html()),
    action: 'alert'
});

window.ModalConfirm = ModalView.extend({
    className: "modal confirm",
    template: _.template($('#modal-template').html()),

    action: 'confirm',

    events: {
      "click .btnYes": "confirm",
      "click .btnNo": "cancel"
    },


    initialize: function() {
      // define what we do on 'yes'
      this.yes = this.options.yes;

      // and what we do on 'no'
      this.no = this.options.no;

      // backbone's version of super()
      this.constructor.__super__.initialize.apply(this, [this.options])
    },

    confirm: function() {
      this.hideModal();
      if (_.isDefined(this.yes) {
        this.yes();
      }
    },

    cancel: function() {
      this.hideModal();

      if (_.isDefined(this.no)) {
        this.no();
      }
    }

});
{% endsyntax %}
<p>&nbsp;</p>

<h2>Underscore.js Template</h2>
<p>Backbone.js has support for several templating engines including Mustache, but for my use case, the template engine in Underscore.js (which Backbone.js ties nicely with since they were developed by the same developer) was more than enough.</p>
<p>This is the code to define the template for the modal windows</p>

{% syntax '', 'Underscore.js Template' %}
<script type="text/template" id="modal-template">
    <% if (typeof(title) != "undefined") { %>
    <div class="modal-header">
        <h1><%= title %></h1>
    </div>
    <% } %>
    <div class="modal-content"><p><%= content %></p></div>
    <div class="modal-footer">

            <% if (action  == 'confirm') { %>
            <a href="#" class="btn blue btnYes">Yes</a>
            <a href="#" class="btn orange btnNo">No</a>
            <% } %>

            <% if (action == 'alert') { %>
                <a href="#" class="btn orange btnClose">OK</a>
            <% } %>
    </div>
</script>
{% endsyntax %}

<p>&nbsp;</p>
<h2>Usage</h2>
<p>It's really simple to use these views.</p>
<p>
  To create an Alert Modal, we simply do:
  {% syntax 'javascript','Alert Modal' %}
  my_alert = new ModalAlert({
      title: 'stop!',
      content: 'you did something terrible!'
  });
  {% endsyntax %}
</p>
<p>
  To create a Confirm Modal is much the same, but with the addition of <strong>yes</strong> and <strong>no</strong> arguments, which define functions to call if the user chooses 'yes' or 'no' on the confirmation dialog.
  {% syntax 'javascript','Confirm Modal' %}
  reset = new ModalConfirm({
      content: 'Are you sure you want to Restart? This will clear everything and start over.',
      title: 'Are you sure?',

      // yes / no functions can either be new functions or predefined functions elsewhere in
      // your app

      yes: App.reset(),
      no: function() {
        new ModalAlert({
            content: 'So glad you decided to not to restart'
        })
      }});
  {% endsyntax %}
</p>

<p>&nbsp;</p>
<h2>Conclusion</h2>
<p>These snippets make it super simple to create alerts and confirms on the fly from anywhere in your code.  This little snippet of code is just one of the examples of what a joy it is to work with a Javascript MVC framework like Backbone.js.  Previous to frameworks like these, creating Modal windows was very clunky, with either needing to define html elements ahead of time or mess around with AJAX calls.</p>
<p>I can see why people love JS MVC frameworks and I'm kind of mad at myself it took so long to try them out.  I can really see this style of coding, letting the client handle most of the logic and the server just handle the data via REST API's, becoming the defacto on the internet in the next few years.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

