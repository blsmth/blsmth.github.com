---
extends: base.j2
default_block: main
title: Code Samples - Google Docs Tables
description:
---



<h1>Google Docs Tables</h1>

<p>This code sample shows the pieces of code that come together to allow content editors on NPP's site to include a DataTable (extremely powerful jQuery table library) powered table pulled in directly from Google Docs into publications simply by including the tag {% raw %}{% googledoctable id=3 %}{% endraw %} where id is the id of the GoogleDocTable object entered through the Django Admin.</p>

<p>I'll give a brief explanation of each piece of the puzzle.</p>
<p>&nbsp;</p>

<h2>GoogleDocTable class (Django Model)</h2>

<p>First, we have the Django Model that defines our database object that will store the data pulled in from Google.  The user enters a GoogleDocTable object in the back-end of the Django Admin, which is a pretty straight-forward process.  Upon saving the new object, the script will reach out to Google Docs and pull in the spreadsheet based on the key field.  It will then pickle this data and store it for access later.  Orginally the idea was to pull this data from Google each time but this proved to be far too slow and cludgy so I opted to pickle the data and store it locally.</p>

{% syntax 'python', 'tables/models.py'  %}
class GoogleDocTable(models.Model):
    title = models.CharField("Title",max_length=200,blank=False,null=False)
    slug = models.SlugField()
    description = models.TextField("Description",blank=True)
    key = models.CharField("Google Docs Key",max_length=256,blank=False, null=False,
        help_text="Google Docs Key for this spreadsheet.  This can be found  \
        in the URL for your Google Doc")
    worksheet = models.IntegerField("Worksheet ID",blank=True,default=1)
    notes = models.CharField("Notes",max_length=128,blank=True,null=True)
    formatters = models.CharField("Formatters",max_length=128,blank=True,null=True,
        help_text="Comma seperated list of formatters for this table. \
        (Valid Formatters: full_state,$,%,none - full_state converts from abbreviation to full state name.")
    datatable_options = models.TextField("Datatable Options",blank=True,null=True,
        help_text="Here you can specify options in the form of JSON objects.  See the wiki for more useful info")
    header = models.CharField("Header",max_length=128,blank=True,null=True,editable=False)
    data = models.TextField("Data",editable=False,blank=True,null=True)
    processed = models.BooleanField(editable=False,default=False)


    class Meta:
        verbose_name = "Google Doc Table"
        verbose_name_plural = "Google Doc Tables"

    def __unicode__(self):
        return unicode(self.title)

    def datatable_options_json(self):
        return json.dumps(self.datatable_options)

    def update(self):
        ''' update()
        this method updates the table from the Google Docs spreadsheet and stores
        the data in a pickled format '''

        # grab the spreadsheet from google docs
        gs = GoogleSpreadsheet(key=self.key,worksheet=self.worksheet)

        try:
            # get the tabular data
            data = gs.tabular()

            # grab the header from the first row and pop it
            header = data[0]
            data.pop(0)

            self.header = pickle.dumps(header)
            self.data = pickle.dumps(data)
            self.processed = False
            self.save()
            return True
        except:
            return False

    def unpickeled_data(self):
        ''' return unpickled data
        we need the str() call because of the way Django stores pickled
        data in the database '''
        return unicode(pickle.loads(str(self.data)))

    def process(self):
        ''' this method processes data in the format of lists of lists and
        updates according to any specified formatters (see formatters field)'''

        data = pickle.loads(str(self.data))
        if self.formatters is not None:
            formatters = self.formatters.split(',')
        tmp_data = []
        for row in data:
            x = 0
            tmp_row = []
            for value in row:
                value = value.strip("$").strip("%").replace(',','')
                if formatters[x] == 'full_state':
                    value = state_lookup(value)
                elif formatters[x] == "$":
                    value = currency(value)
                elif formatters[x] == "%":
                    value = ("%0.2f" % float(value)) + " %"
                tmp_row.append(value)
                x += 1
            tmp_data.append(tmp_row)

        self.data = pickle.dumps(tmp_data)
        self.processed = True
        self.save()

    def save(self, *args, **kwargs):
        ''' make sure we pull in data and process if needed '''
        if self.data is None:
            self.update()
        if not self.processed:
            self.process()
        super(GoogleDocTable,self).save(*args, **kwargs)
{% endsyntax %}

<p>&nbsp;</p>

<h2>GoogleSpreadsheet class</h2>
<p>This class is the real meat of what's happening here.  It's a very thin wrapper over the somewhat convoluted GData API from Google to reach out to their service and pull in data from their Google Docs service.

<p>I started in on this class/module with the intention of turning it into a full fledged API to talk to the Google Docs service, but time did not permit.  The spreadsheet class is very functional however and has proved very useful for NPP.</p>

{% syntax 'python','utils/googletools.py' %}
import gdata.spreadsheet.service
import gdata.service
import gdata.spreadsheet

from django.conf import settings
from utils import lazyprop # lazy property evaluation

GOOGLE_DOCS_USER = getattr(settings, 'GOOGLE_DOCS_USER')
GOOGLE_DOCS_PASSWORD = getattr(settings, 'GOOGLE_DOCS_PASSWORD')

class GoogleSpreadsheet(object):
    ''' An iterable google spreadsheet object.  Each row is a dictionary
    with an entry for each field, keyed by the header.
    requires GData module from google .'''

    def __init__(self, key, worksheet='1', user=GOOGLE_DOCS_USER,
        password=GOOGLE_DOCS_PASSWORD, source=''):
        service = gdata.spreadsheet.service.SpreadsheetsService()
        service.email = user
        service.password = password
        service.source = source

        # authenticate with google
        service.ProgrammaticLogin()

        self.service = service
        self.key = key
        self.worksheet = worksheet
        self.count = 0


    # these next properties are loaded lazily to avoid uneeded
    # heavy calls to Google on big spreadsheets
    @lazyprop
    def cell_feed(self):
        ''' representation of GData's CellsFeed '''
        return self.service.GetCellsFeed(self.key, self.worksheet)

    @lazyprop
    def list_feed(self):
        ''' representation of GData's ListFeed '''
        return self.service.GetListFeed(self.key, self.worksheet)

    @lazyprop
    def col_count(self):
        ''' column count '''
        return int(self.cell_feed.col_count.text)
    @lazyprop
    def row_count(self):
        ''' row count '''
        return int(self.cell_feed.row_count.text)

    @lazyprop
    def rows(self):
        ''' returns a list of dictionary representations of each row '''
        rows = []
        for entry in self.list_feed.entry:
            d = {}
            for key in entry.custom.keys():
                d[key] = entry.custom[key].text
            rows.append(d)
        return rows



    def tabular(self):
        ''' return rows a list of lists
        useful for outputting directly to html tables '''
        rows = []
        cur_row = 1
        count = 0
        while cur_row <= self.row_count:
            cur_col = 1
            row = []
            while cur_col <= self.col_count:
                try:
                    row.append(self.cell_feed.entry[count].cell.text)
                except IndexError:
                    # empty cells
                    pass
                cur_col += 1
                count += 1
            cur_row += 1
            rows.append(row)
            del row
        return rows

    def next(self):
        if self.count >= len(self.rows):
            self.count = 0
            raise StopIteration
        else:
            self.count += 1
            return self.rows[self.count - 1]

    def insert_row(self, row_data):
        ''' insert a row into document.
        must be in the form of a dictionary '''
        entry = self.service.InsertRow(row_data,
            self.key, self.worksheet)
        if isinstance(entry, gdata.spreadsheet.SpreadsheetsList):
            print 'Successfully Inserted'
        else:
            print entry


    # override some built-ins
    def __getitem__(self, item):
        ''' allow rows to be accessed directly '''
        return self.rows[item]

    def __len__(self):
        ''' allow to call len() on object '''
        return len(self.rows)
{% endsyntax %}

<p>&nbsp;</p>

<h2>Template Tag</h2>
<p>This is template tag built on top of the fabulous django-classytags library that allows for easy creation of class based tags.  The tag can take one of two arguments: <em>id</em> and <em>slug</em>. the useage of this tag would simply be:
    {% syntax 'html','' %}
    {% raw %}
    {% load table_tags %}
    {% googledoctable id=3 %} or {% googledoctable slug='some-really-cool-table' %}
    {% endraw %}
    {% endsyntax %}
</p>

{% syntax 'python', 'tables/templatetags/tables_tags.py'  %}
from django import template
from tables.models import Table, GoogleDocTable
from classytags.core import Options
from classytags.arguments import MultiKeywordArgument
from classytags.helpers import InclusionTag

register = template.Library()

class GoogleDocTableTag(InclusionTag):
    name='googledoctable'
    template = 'tables/googledoctable.html'
    options = Options(
        MultiKeywordArgument(name="_kwargs",required=False),
    )

    def get_table(self, _kwargs):
        ''' find table via slug or id '''
        slug = _kwargs.get('slug',None)
        id = _kwargs.get('id',None)

        if slug is not None:
            table = GoogleDocTable.objects.get(slug=slug)
        elif id is not None:
            try:
                table = GoogleDocTable.objects.get(id=id)
            except:
                table = None
        return table

    def get_context(self, context, _kwargs):
        ''' load table into context '''
        table = self.get_table(_kwargs)
        header = pickle.loads(str(table.header))
        context.push()
        context['table'] = table
        context['data'] = pickle.loads(str(table.data))
        context['header'] = header
        context.pop()
        return context

register.tag(GoogleDocTableTag)

{% endsyntax %}

<p>&nbsp;</p>
<h2>Django Template</h2>
<p>This is the Django Template that is loaded via the InclusionTag seen above. This code simply takes the GoogleDocTable object and converts it to a proper html table.  Then some jQuery magic is applied via the DataTable package and you have a beautiful looking table.  I messed around with DataTable's json loading features but in the end decided it was best to display a traditional html table so anyone not running Javascript would still be able to see the old fashioned html table.</p>

{% syntax 'django', 'Django Template' %}
{% raw %}
{% load sekizai_tags tables_tags humanize %}
<div id="{{ table.slug }}" name="{{ table.slug }}" class="datatable">
<h2 class="tablesorter-title">{{ table.title }}</h2>
<p>{{ table.description|safe }}</p>
    <table id="{{ table.slug }}-datatable" class="tablesorter">
        <thead>
        <tr>
            {% for column in header %}
            <th>{{ column }}</th>
            {% endfor %}
        </tr>
        </thead>

    {% for row in data %}
        <tr>
            {% for v in row %}
            <td>{{ v|intcomma }}</td>
            {% endfor %}
        </tr>
    {% endfor %}
    </table>
</div>


{% addtoblock 'js' %}
<script type="text/javascript" src="{{ STATIC_URL }}datatables/js/jquery.dataTables.js"></script>
{% endaddtoblock %}

{% addtoblock 'js_code' %}
table_list = [];
{% endaddtoblock %}

{% addtoblock 'js_code' %}
table_list.push({'title': '{{ table.title|escapejs }}','slug': '{{ table.slug }}'});
{% endaddtoblock %}


{% addtoblock 'document_ready' %}
    $('#{{ table.slug }}-datatable').dataTable({
        {% if table.datatable_options %}
        {{ table.datatable_options|safe }},
        {% endif %}
         "sPaginationType": "full_numbers"
    });
{% endaddtoblock %}
{% endraw %}
{% endsyntax %}



<p>&nbsp;</p>
<h2>Working Example</h2>
<p>You can see a working example of this code at the page:<br/> <a href="http://nationalpriorities.org/en/analysis/2012/presidents-budget-fy2013/federal-spending-your-state/" target="_blank">http://nationalpriorities.org/en/analysis/2012/presidents-budget-fy2013/federal-spending-your-state/</a></p>
<p>All of the fancy tables on this page were created with the code I've outlined here.</p>



<p>&nbsp;</p>
<h2>Conclusion</h2>
<p>I chose this as one of my code samples because it shows a few different pieces of code in different places that come together to form a really useful and elegant solution.  The use of these tables and the GoogleSpreadsheet class have proved extremely valuable for NPP.</p>
<p>If you have any questions about this code, please feel free to contact me.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
